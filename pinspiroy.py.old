#!/usr/bin/python

# *** archived attempt using python-uinput
# didn't work as I needed EV_MSC calls

import sys
import usb.core
import usb.util
import uinput
import time


vtrack = uinput.Device([
	#button pad
	uinput.KEY_UNDO,				# 2 undo
	uinput.KEY_REDO,				# 4 redo
	uinput.KEY_LEFTCTRL,		# 8 ctrl, eyedropper

	#gestures
	uinput.BTN_LEFT,					# single tap, mouse click

	#trackpad
	uinput.BTN_TOUCH,
	uinput.ABS_X+(0,198*255,0,0),
	uinput.ABS_Y+(0,255*124,0,0),
])

#pad
vpad = uinput.Device([
	uinput.BTN_TOUCH,
	uinput.BTN_TOOL_PEN,
	uinput.ABS_X+(0,50800,0,0),
	uinput.ABS_Y+(0,31750,0,0),
	uinput.ABS_PRESSURE+(0,2048,0,0),
	])
time.sleep(1)

# decimal vendor and product values
dev = usb.core.find(idVendor=0x256c, idProduct=0x006e)
# first endpoint
interface = 0
endpoint = dev[0][(0,0)][0]
# if the OS kernel already claimed the device, which is most likely true
# thanks to http://stackoverflow.com/questions/8218683/pyusb-cannot-set-configuration
if dev.is_kernel_driver_active(interface) is True:
	# tell the kernel to detach
	dev.detach_kernel_driver(interface)
	# claim the device
	usb.util.claim_interface(dev, interface)

interface = 1
if dev.is_kernel_driver_active(interface) is True:
	# tell the kernel to detach
	dev.detach_kernel_driver(interface)
	# claim the device
	usb.util.claim_interface(dev, interface)

# input IDS; [1] in data array

def id_btn(data):
	print (data)
	#button_id[data[4]]()

def id_gst(data):
	print (data)
	#vtrack.emit(uinput.BTN_LEFT,1)

def id_trk(data):
	print(data)
	x = data[3]*255 + data[2]
	y = data[5]*255 + data[4]
	vtrack.emit(uinput.ABS_X,x)
	vtrack.emit(uinput.ABS_Y,y)


def id_pad(data):
	#print (data)
	x = data[3]*255 + data[2]
	y = data[5]*255 + data[4]
	z = data[7]*255 + data[6]
	print(str(x) + ', ' + str(y) + '; ' + str(z))

	vpad.emit(uinput.ABS_X,x,syn=False)
	vpad.emit(uinput.ABS_Y,y,syn=True)
	vpad.emit(uinput.ABS_PRESSURE,z,syn=False)
	if data[1] != 129:
		vpad.emit(uinput.BTN_TOUCH,0,syn=False)
		vpad.emit(uinput.BTN_TOOL_PEN,1,syn=False)
	else:
		vpad.emit(uinput.BTN_TOUCH,1,syn=False)
		vpad.emit(uinput.BTN_TOOL_PEN,1,syn=False)
	time.sleep(0.02)

input_id = {
	224:id_btn, #buttonpad 
	225:id_gst, #trackpad gestures
	144:id_trk, #trackpad movement
	129:id_pad, #stylus down
	128:id_pad, #stylus up
	130:id_pad, #stylus button 1
	132:id_pad #stylus button 2
}

def b_nothing():
	print('released')

def b_ctrl():
	#vtrack.emit(uinput.KEY_LEFTCTRL,1)
	print('ctrl')
def b_undo():
	#vtrack.emit_click(uinput.KEY_UNDO,1)
	print('undo')

button_id = {
	0:b_nothing,
	1:b_ctrl,
	2:b_undo,
}


	

# stylus pad coords; x [2] and [3] in array, y [4,5]
PAD_MAX_X = [102,198]
PAD_MAX_Y = [29,129]

# stylus pressure [6,7]
PRESSURE_MAX = [255,7]

# trackpad coordinates
TRACK_MAX_X =  [112,198] 
TRACK_MAX_Y = [6,124]


collected = 0
attempts = 10000
while collected < attempts :
		try:
				data = dev.read(endpoint.bEndpointAddress,endpoint.wMaxPacketSize)
				#print (data)
				input_id[data[1]](data)
		except usb.core.USBError as e:
				data = None
				if e.args == ('Operation timed out',):
						continue
# release the device
usb.util.release_interface(dev, interface)
# reattach the device to the OS kernel
dev.attach_kernel_driver(interface)